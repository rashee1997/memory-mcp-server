# Plan: Dedicated Tables for Enhanced Plan and Task Management in memory-mcp-server

Refined Prompt Overall Goal: Refactor the `memory-mcp-server` to use dedicated database tables for "plans" and "plan_tasks" (with statuses). Implement functionality for creating plans with tasks, retrieving tasks filtered by status, and deleting plans with cascading deletion of their associated tasks. This will ensure plan/task data is isolated and fetching is optimized.

Refined Prompt Decomposed Tasks Being Addressed:
1.  Design and implement new, separate database tables: `plans` and `plan_tasks`.
2.  Develop `MemoryManager` methods for creating a plan along with its tasks in these new tables.
3.  Implement `MemoryManager` methods for retrieving plan details and for retrieving specific tasks from a plan, filtered by status.
4.  Implement `MemoryManager` methods for updating the status of plans and individual tasks.
5.  Implement a `MemoryManager` method for deleting a plan, ensuring all its associated tasks are also deleted via cascading delete.
6.  Define and implement new MCP tools in `index.ts` to expose these dedicated plan and task management functionalities, replacing the previous approach of using generic `store_context` for plans.
7.  Update API documentation and validation schemas to reflect the new tools and data structures.

Overall Approach:
This plan introduces two new primary tables: `plans` for plan-level information and `plan_tasks` for the individual tasks/steps within those plans. The `plan_tasks` table will have a foreign key relationship to the `plans` table with `ON DELETE CASCADE` to handle automatic deletion of tasks when a plan is deleted. The generic `context_information` table will **no longer** be used for storing plan or task data. This provides clear data separation and allows for optimized SQL queries directly on plan and task attributes like status.

Acceptance Criteria for Overall Goal:
1.  The `memory-mcp-server` uses new, dedicated `plans` and `plan_tasks` tables.
2.  New MCP tools are available for creating plans with their tasks, and these are stored in the new dedicated tables.
3.  An MCP tool allows retrieval of tasks from a specific plan, with an option to filter these tasks by their status (e.g., "COMPLETED", "PLANNED").
4.  MCP tools are available to update the status of a plan and the status of individual tasks.
5.  An MCP tool for deleting a plan successfully removes the plan record and all its associated task records.
6.  Plan and task data is clearly isolated from other types of context stored in `context_information`.
7.  Documentation accurately reflects these changes.

Key Assumptions:
* `agent_id` will scope all plans and tasks.
* Plan and task statuses are represented as text (e.g., "PLANNED", "IN_PROGRESS", "COMPLETED").
* The relationship between plans and tasks is one-to-many.

Risks & Mitigation:
* **Risk:** Existing logic relying on plans being in `context_information` will break.
    * **Mitigation:** This is an intentional breaking change for better structure. The agent-side logic interacting with plans will need to be updated to use the new dedicated tools. This plan assumes this is a new or refactored system design.
* **Risk:** Complexity of managing transactional inserts for a plan and its multiple tasks.
    * **Mitigation:** `MemoryManager` methods should encapsulate this. Use database transactions if available and appropriate in the `sqlite` wrapper to ensure atomicity when creating a plan and its initial set of tasks.

---
Steps:

1.  **Define Schema for New `plans` and `plan_tasks` Tables**
    * **Purpose:** Create dedicated, normalized tables for plans and their tasks.
    * **Action:** Modify `src/database/schema.sql` to add the following table definitions. Remove any previous `plan_steps` table definition if it was added from the prior plan.
        ```sql
        -- New table for Plans
        CREATE TABLE IF NOT EXISTS plans (
            plan_id TEXT PRIMARY KEY,                   -- Unique ID for the plan (e.g., UUID generated by agent or server)
            agent_id TEXT NOT NULL,                     -- Scopes plan to an agent
            title TEXT NOT NULL,
            overall_goal TEXT,
            status TEXT NOT NULL DEFAULT 'DRAFT',       -- e.g., DRAFT, APPROVED, IN_PROGRESS, COMPLETED, HALTED, FAILED
            version INTEGER NOT NULL DEFAULT 1,
            creation_timestamp INTEGER NOT NULL,
            last_updated_timestamp INTEGER NOT NULL,
            refined_prompt_id_associated TEXT,        -- Optional: link to a refined prompt context
            analysis_report_id_referenced TEXT,       -- Optional: link to a code analysis report context
            metadata TEXT                               -- JSON blob for any other plan-level misc info
        );

        CREATE INDEX IF NOT EXISTS idx_plans_agent_id ON plans (agent_id);
        CREATE INDEX IF NOT EXISTS idx_plans_agent_id_status ON plans (agent_id, status);

        -- New table for Plan Tasks (previously plan_steps)
        CREATE TABLE IF NOT EXISTS plan_tasks (
            task_id TEXT PRIMARY KEY,                   -- Unique ID for the task (e.g., UUID)
            plan_id TEXT NOT NULL,                      -- FK to plans.plan_id
            agent_id TEXT NOT NULL,                     -- Scopes task to an agent (denormalized for easier querying if needed)
            task_number INTEGER NOT NULL,               -- Order of the task in the plan
            title TEXT NOT NULL,
            description TEXT,
            status TEXT NOT NULL DEFAULT 'PLANNED',     -- e.g., PLANNED, IN_PROGRESS, COMPLETED, FAILED, BLOCKED, SKIPPED
            purpose TEXT,
            action_description TEXT,
            files_involved TEXT,                        -- JSON array of strings
            dependencies_task_ids TEXT,               -- JSON array of task_ids this task depends on
            tools_required_list TEXT,                 -- JSON array of strings
            inputs_summary TEXT,
            outputs_summary TEXT,
            success_criteria_text TEXT,
            estimated_effort_hours REAL,
            assigned_to TEXT,
            verification_method TEXT,
            creation_timestamp INTEGER NOT NULL,
            last_updated_timestamp INTEGER NOT NULL,
            completion_timestamp INTEGER,               -- Timestamp when task was marked COMPLETED or FAILED
            notes TEXT,                                 -- JSON blob for task-specific notes or sub-results
            FOREIGN KEY (plan_id) REFERENCES plans(plan_id) ON DELETE CASCADE -- Ensures tasks are deleted if parent plan is deleted
        );

        CREATE INDEX IF NOT EXISTS idx_plan_tasks_plan_id ON plan_tasks (plan_id);
        CREATE INDEX IF NOT EXISTS idx_plan_tasks_agent_id_status ON plan_tasks (agent_id, status);
        CREATE INDEX IF NOT EXISTS idx_plan_tasks_plan_id_status ON plan_tasks (plan_id, status);
        ```
    * **File(s) Involved:** `src/database/schema.sql`
    * **Success Criteria:** Tables `plans` and `plan_tasks` are correctly created with specified columns, types, primary keys, foreign keys (with `ON DELETE CASCADE` for `plan_tasks.plan_id`), and indexes.

2.  **Implement `MemoryManager` Methods for Plan and Task CRUD Operations**
    * **Purpose:** Create the backend logic for managing plans and tasks in the new tables.
    * **Action:** Add the following methods to `src/database/memory_manager.ts`.
        1.  `async createPlanWithTasks(agent_id: string, planData: object, tasksData: object[]): Promise<{plan_id: string, task_ids: string[]}>`
            * Generates a `plan_id`.
            * Inserts a record into the `plans` table.
            * For each task in `tasksData`, generates a `task_id`, links it to `plan_id`, and inserts it into `plan_tasks`.
            * Should ideally use a database transaction to ensure atomicity.
        2.  `async getPlan(agent_id: string, plan_id: string): Promise<object | null>`
            * Retrieves a single plan by `plan_id` and `agent_id` from the `plans` table.
        3.  `async getPlans(agent_id: string, status_filter?: string, limit?: number, offset?: number): Promise<object[]>`
            * Retrieves a list of plans for an agent, optionally filtered by plan status.
        4.  `async getPlanTasks(agent_id: string, plan_id: string, status_filter?: string, limit?: number, offset?: number): Promise<object[]>`
            * Retrieves tasks for a given `plan_id` (and `agent_id`), optionally filtered by `status_filter` from `plan_tasks`.
        5.  `async updatePlanStatus(agent_id: string, plan_id: string, new_status: string): Promise<boolean>`
            * Updates the `status` and `last_updated_timestamp` of a plan in the `plans` table.
        6.  `async updateTaskStatus(agent_id: string, task_id: string, new_status: string, completion_timestamp?: number): Promise<boolean>`
            * Updates the `status`, `last_updated_timestamp`, and optionally `completion_timestamp` of a task in `plan_tasks`.
        7.  `async deletePlan(agent_id: string, plan_id: string): Promise<boolean>`
            * Deletes a plan from the `plans` table. Associated tasks in `plan_tasks` should be deleted automatically due to `ON DELETE CASCADE`. Verify this behavior.
        8.  `async getTask(agent_id: string, task_id: string): Promise<object | null>` (Optional, for fetching individual tasks directly)
    * **File(s) Involved:** `src/database/memory_manager.ts`
    * **Success Criteria:** Methods are implemented, perform correct database operations, handle errors, and include necessary data parsing/stringification for JSON fields.

3.  **Define and Implement New MCP Tools in `index.ts`**
    * **Purpose:** Expose the new plan and task management functionalities via MCP.
    * **Action:** Modify `src/index.ts` and `src/utils/validation.ts`.
        1.  **New Tool: `create_task_plan`**
            * **Description:** "Creates a new task plan with its initial set of tasks."
            * **`inputSchema`:** (Define schema for plan details and an array of task details, including `agent_id`).
            * Calls `memoryManager.createPlanWithTasks()`.
        2.  **New Tool: `get_task_plan_details`**
            * **Description:** "Retrieves details for a specific task plan."
            * **`inputSchema`:** (`agent_id`, `plan_id`).
            * Calls `memoryManager.getPlan()`.
        3.  **New Tool: `list_task_plans`** (Optional, if `getPlans` is implemented)
            * **Description:** "Lists task plans for an agent, optionally filtered by status."
            * **`inputSchema`:** (`agent_id`, `status_filter?`, `limit?`, `offset?`).
            * Calls `memoryManager.getPlans()`.
        4.  **New Tool: `get_plan_tasks`**
            * **Description:** "Retrieves tasks for a specific plan, optionally filtered by status."
            * **`inputSchema`:** (`agent_id`, `plan_id`, `status_filter?`, `limit?`, `offset?`).
            * Calls `memoryManager.getPlanTasks()`.
        5.  **New Tool: `update_task_plan_status`**
            * **Description:** "Updates the status of a specified task plan."
            * **`inputSchema`:** (`agent_id`, `plan_id`, `new_status`).
            * Calls `memoryManager.updatePlanStatus()`.
        6.  **New Tool: `update_plan_task_status`**
            * **Description:** "Updates the status of a specific task within a plan."
            * **`inputSchema`:** (`agent_id`, `task_id`, `new_status`).
            * Calls `memoryManager.updateTaskStatus()`.
        7.  **New Tool: `delete_task_plan`**
            * **Description:** "Deletes a task plan and all its associated tasks."
            * **`inputSchema`:** (`agent_id`, `plan_id`).
            * Calls `memoryManager.deletePlan()`.
        8.  Update `ListToolsRequestSchema` handler to include these new tools.
        9.  Add corresponding validation schemas in `src/utils/validation.ts`.
    * **File(s) Involved:** `src/index.ts`, `src/utils/validation.ts`
    * **Success Criteria:** New tools are registered, correctly call `MemoryManager` methods, inputs are validated, and appropriate responses are returned. The old way of storing plans via generic `store_context` should be deprecated or removed for plans.

4.  **Update RIPER-5 Protocol Document**
    * **Purpose:** Ensure the agent's operational protocol reflects these new dedicated tools for plan and task management.
    * **Action:** Modify the `riper_5_protocol_full_v1` document (or create a new version).
        * In **MODE 4: PLAN** (`Task Storage in Memory` section), change from using `store_context` to using the new `create_task_plan` tool. Update the example `context_data` to match the input schema of `create_task_plan`.
        * In **MODE 5: EXECUTE** (`Entry Requirement` and `Task Progress Logging` sections), update how plans are retrieved (using `get_task_plan_details` and `get_plan_tasks`) and how task statuses are updated (using `update_plan_task_status`). Task progress logging might still use `store_context` with `context_type: "task_progress_log_v1"`, but now it should reference `plan_id` and `task_id` from the new dedicated tables.
        * In **MODE 6: REVIEW**, update how plan and task data is retrieved for review.
        * Update Mandate 11's list of available tools.
    * **File(s) Involved:** `riper_5_protocol_full_v1` (conceptual update, to be generated as HTML later).
    * **Success Criteria:** The RIPER-5 protocol accurately describes agent interactions with the new plan/task management system.

5.  **Update API and Implementation Documentation**
    * **Purpose:** Document the new tables, `MemoryManager` methods, and MCP tools.
    * **Action:**
        * Update `docs/api_documentation.md` with details for all new and modified MCP tools.
        * Update `docs/implementation_notes.md` and potentially `docs/README.md` to describe the new `plans` and `plan_tasks` tables and their relationship, explaining why this separation was made.
    * **File(s) Involved:** `docs/api_documentation.md`, `docs/implementation_notes.md`, `docs/README.md`.
    * **Success Criteria:** Documentation is comprehensive, accurate, and reflects the new architecture.

6.  **Testing**
    * **Purpose:** Verify all new and modified functionalities.
    * **Action:**
        * Write unit tests for all new `MemoryManager` methods.
        * Conduct integration tests by calling the new MCP tools. Specifically test:
            * Plan and task creation.
            * Retrieval of plans and tasks (especially task filtering by status).
            * Status updates for plans and tasks.
            * Cascading delete of tasks when a plan is deleted.
            * Edge cases (e.g., deleting a non-existent plan, updating a non-existent task).
    * **File(s) Involved:** (Test suite files).
    * **Success Criteria:** All tests pass, data integrity is maintained, and functionality meets requirements.

---
End of Plan